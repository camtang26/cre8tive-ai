### 5.2 Keep the Main Thread Free (avoid long tasks)

Animations run on the main thread (unless using CSS/WAAPI offload for some, but GSAP as JS runs on main). So you want each frame's work to be minimal: - **No heavy computations in onUpdate:** If you have an onUpdate callback on a tween that does something expensive (like traversing DOM or heavy math), that could kill performance. If you need to do math (e.g., simulate physics), try to precompute as much as possible or do it in small steps. For complex physics, consider GSAP's physics plugins instead of writing in onUpdate. - **Split big reflows into steps:** If you must measure and set layout repeatedly (rare in GSAP usage, but e.g., a custom layout/animation interplay), avoid doing a read (like element.offsetHeight) followed immediately by write (setting style) in same frame repeatedly -- this causes forced reflow each time. Instead, batch reads together, then writes. GSAP's rendering engine generally helps by doing style writes all together, but if you do manual DOM work, be mindful. - **Web Workers for logic:** If you had a very computation-heavy task (like calculating thousands of particle positions), you could offload to a Web Worker and then use GSAP to animate the final values. This is advanced and rarely needed for typical UI animations, but it's an option if CPU logic is a bottleneck. - **Use GSAP's timeline for delays over setTimeout:** Using GSAP's timeline or delayedCall ensures that when the browser tab is inactive, it won't try to animate (GSAP is tied to requestAnimationFrame which pauses when tab not visible, whereas setTimeout might still run and queue tasks). This reduces unnecessary work in background tabs. - **RAF-synchronized loops:** If you do create your own loop (rare because GSAP covers most needs), always sync with rAF. E.g., don't set `setInterval(fn, 16)` for an animation loop; use `gsap.ticker` or `requestAnimationFrame` to ensure you're in sync with screen refresh.
