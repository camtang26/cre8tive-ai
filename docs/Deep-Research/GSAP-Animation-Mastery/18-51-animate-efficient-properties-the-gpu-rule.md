### 5.1 Animate Efficient Properties (the "GPU rule")

As mentioned earlier, animating CSS properties can be split into categories: - **GPU-accelerated, inexpensive:** transform (translate, rotate, scale), opacity, and some filters (on modern browsers, simple filters like brightness or blur might be GPU accelerated but be careful). These do not trigger layout or paint (except for the element being composited). The browser can handle these very efficiently by using the GPU to composite layers. - **Expensive (layout/reflow triggers):** top, left, right, bottom (changes layout of the page), width, height (reflows layout unless isolated), margin, padding, etc. Animating these means on each frame the browser recalculates the layout of possibly many elements -- very slow. **Avoid animating these if at all possible.** - **Paint-heavy:** color changes, box-shadow, gradient, or any property that doesn't affect layout but requires repaint of pixels. These are moderately expensive -- one box-shadow change might be fine, but animating a large drop shadow on many elements is costly. If you animate color or shadows, do it on few elements or less frequent updates.

**Rule of thumb:** stick to `transform` and `opacity` in your tweens for core motion[\[19\]](https://gsap.com/community/forums/topic/23062-questions-about-performance-best-practices/#:~:text=Performance%20problems%20are%20almost%20always,much%20faster%20than%20animating%20left%2Ftop). GSAP's default approach encourages that (x, y, scale, rotation all use CSS transforms). If you need to animate others: - To animate height or width for an expanding element, consider using scaleY/scaleX (with transform-origin set appropriately) as an alternative. Or animate max-height from 0 to some value (with caution: that still triggers layout of that element's contents, but scope is limited). - To animate position, use x/y instead of left/top (the element should be relatively or absolutely positioned so that x=100 effectively moves it visually). - For scroll-based effects like parallax, don't update `scrollTop` each frame -- instead use transforms on content inside a container.

Modern browsers also optimize certain things: - If an element is on its own layer (either via `will-change` or because it's being transformed), changes to it don't reflow siblings. So isolating animated elements can confine repaints. - `will-change: transform` can be added to hint the browser to prep a layer[\[20\]](https://gsap.com/community/forums/topic/18097-performance-and-visual-optimizations/#:~:text=When%20animating%20DOM%20elements%2C%20adding,provide%20a%20significant%20performance%20boost). But as noted, don't overuse it: - Good: a large background image that will move continuously -- use will-change so the browser moves it on GPU. - Bad: adding will-change to 100 items that only fade once on load -- that's overkill, layers use memory and can reduce overall performance if too many.

**Practical tip:** Use Chrome DevTools "Layers" panel to see how many layers your page has. Each will-change or transform can create a layer. Too many can strain memory or composition. Typically under 10 layers is fine; dozens might be an issue on mobile.
