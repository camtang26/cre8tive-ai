### 2.4 Performance Patterns and Optimization Techniques

GSAP is designed to be high-performance, but animation performance also depends on *what* and *how* you animate. Here are crucial patterns to ensure 60fps, jank-free animations: - **Animate Transform and Opacity, Not Layout:** This is the golden rule. Transforms (like `x, y, scale, rotation`) and opacity can typically be animated without triggering layout (reflow) -- the browser uses the GPU to composite these changes. In contrast, animating properties like `top/left`, `width/height`, or any CSS that affects document flow can trigger layout calculations each frame, which is slow. **Always prefer** using `x` instead of `left`, `y` instead of `top`, `scale` instead of width changes, etc.[\[19\]](https://gsap.com/community/forums/topic/23062-questions-about-performance-best-practices/#:~:text=Performance%20problems%20are%20almost%20always,much%20faster%20than%20animating%20left%2Ftop). For example, to move an element 100px right, use `x:100` (GSAP applies it via CSS transform under the hood) rather than animating `left:100px`. The visual result is the same, but the performance difference is huge. AI should default to transforms. - **Use** `will-change` **(sparingly) to optimize heavy elements:** The CSS `will-change: transform;` hint can ask the browser to optimize rendering of an element (likely putting it on its own layer)[\[20\]](https://gsap.com/community/forums/topic/18097-performance-and-visual-optimizations/#:~:text=When%20animating%20DOM%20elements%2C%20adding,provide%20a%20significant%20performance%20boost). This can boost performance for elements with continuous animation. GSAP's docs caution it's not a magic bullet -- overusing `will-change` can waste memory and even hurt performance[\[21\]](https://gsap.com/community/forums/topic/18097-performance-and-visual-optimizations/#:~:text=,provide%20a%20significant%20performance%20boost). So apply it only to elements with known heavy animations (e.g., an element that's frequently moving or scaling). Example: `.card { will-change: transform; }` in your CSS for elements you animate a lot. The **GSAP Flip plugin** automatically adds `will-change` during animations to optimize and then removes it[\[22\]](https://www.awwwards.com/building-gsap-asap.html#:~:text=) as needed. AI doesn't need to manage will-change for Flip, but for custom animations it can be considered in a performance checklist. - **Batch DOM Read/Writes:** GSAP internally batches updates, but if your code in onUpdate (or scroll events outside GSAP) does DOM queries, be mindful to avoid layout thrash. The pattern is to **read** from DOM (e.g., element positions) separately from **writing** (applying GSAP tweens). One common trick: use GSAP's `gsap.utils.toArray()` to gather element references at start, rather than querying the DOM repeatedly during animation. - **Limit onUpdate Work:** Avoid expensive calculations inside GSAP's `onUpdate` callbacks that run every frame. If you need to do calculations, try to precalc outside and use GSAP's built-in capabilities. For example, instead of updating styles via onUpdate, use GSAP's tweening of those styles. Modern computers are powerful, but many small inefficiencies can add up. *AI note:* Most straightforward GSAP code won't need onUpdate heavy work, but just be cautious if an effect needs per-frame logic (like a complex canvas draw, etc.). - **Use GSAP's advanced utilities for performance:** - **gsap.quickTo()**: If you need to imperatively set a property very frequently (like in a mousemove event), `quickTo` gives a cached optimized setter. E.g., `const quickSetX = gsap.quickTo(element, { x: 0 });` then call `quickSetX(value)` to set quickly without overhead. - **gsap.utils.interpolate() / clamp()**: Useful for computing values without writing heavy custom math each frame. - **Observer** plugin: If doing scroll or drag tracking, using Observer might be more efficient than adding raw event listeners because it can coordinate with GSAP's tick. - **Keep Timelines and Tweens Short-Lived if Offscreen:** Animations running offscreen (if not using ScrollTrigger) still consume resources. If an animation isn't critical, consider pausing it when not in view (you can use IntersectionObserver or ScrollTrigger's `onEnter`/`onLeave` callbacks to pause/resume). For example, a background animation of flying particles could be paused when the user scrolls away from that section to save CPU. This is a level of polish that improves real-world performance, especially on mobile. - **Memory Management -- Kill Unneeded Tweens:** GSAP will automatically clean up finished tweens, but if your single-page app navigates between pages, be sure to kill timelines/triggers on teardown to avoid buildup. For React/Vue, this means cleaning up in `useEffect` return or appropriate lifecycle. We will cover specific cleanup patterns in integration (Part 2.5) and have a checklist in Part 4. A common AI mistake is forgetting to kill a ScrollTrigger on page change, which can lead to "ghost" animations or warnings. Use `ScrollTrigger.getAll().forEach(t => t.kill())` or GSAP Context (discussed soon) for cleanup on transitions. - **Benchmark & Adjust:** Even experts profile their animations. Use DevTools Performance to capture a timeline while an animation runs. Look at frame rates and see if any frame took > 16ms (that's a drop below 60fps). If so, identify the cause (was it paint, script, layout?). Perhaps too many elements animating at once? For instance, animating 500 DOM elements simultaneously will likely jank -- an alternative might be animating a canvas or WebGL particle system instead. Or staggering them more to never animate all at once. *AI cannot run DevTools, but it can incorporate known best practices.* Always keep in mind: **quality animations maintain 60fps**, and if an effect is too heavy, consider simplifying it or offloading work (like using Canvas for heavy graphics). - **Use Reduced Motion for Heavy Animations:** We'll elaborate in Part 6, but respecting `prefers-reduced-motion` isn't just accessibility -- it's also a performance safeguard. Users on low-power devices or who don't want animations can indicate that, and you should respond by disabling or toning down intensive effects for them[\[23\]](https://gsap.com/resources/a11y/#:~:text=Did%20you%20know%20that%20some,for%20people%20with%20motion%20sensitivities)[\[24\]](https://gsap.com/resources/a11y/#:~:text=We%20can%20listen%20to%20this,matchMedia). This ensures those users have a smoother experience.

GSAP itself is highly optimized (minimized garbage collection, etc.), so focus on **animating in a web-optimized way**. As a GSAP core dev said: performance issues are "99.9999% of the time" due to animating too many/inefficient properties, not the GSAP engine[\[25\]](https://gsap.com/community/forums/topic/23062-questions-about-performance-best-practices/#:~:text=People%20always%20ask%20about%20how,optimizing%20it). For example, animating `x` and `y` is cheap, animating an expensive drop-shadow filter on 100 elements is not. The engine can handle a lot; it's our job (or AI's) to animate smartly.

One more tip: **use layering to your advantage.** For example, if animating a blurring background on scroll, consider using a separate fixed-position layer that is blurred (CSS filter) rather than blurring lots of individual elements. Composite that layer behind content. This way you animate one element's filter instead of many -- reducing work. AIs won't automatically know this trick, but it's the type of optimization human devs do.
