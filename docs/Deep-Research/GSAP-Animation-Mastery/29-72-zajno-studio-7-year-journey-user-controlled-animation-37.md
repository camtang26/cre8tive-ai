### 7.2 Zajno Studio -- 7-year Journey (User-Controlled Animation) [\[37\]](https://www.awwwards.com/case-study-7-year-journey-by-zajno.html#:~:text=The%20main%20technical%20challenge%20was,didn%27t%20provide%20the%20desired%20experience)

**Background:** Zajno's case study site "7-year Journey" had a main technical challenge: initially they tried auto-progressing animations, but then realized it's better to give control to the user via scrolling[\[37\]](https://www.awwwards.com/case-study-7-year-journey-by-zajno.html#:~:text=The%20main%20technical%20challenge%20was,didn%27t%20provide%20the%20desired%20experience). They moved to full animation control through scroll.

**What they did:** - They likely built a long scrollsequence (like a pseudo-video) of 3D scenes and text. The user scrolls and the site advances through "years" of history. - GSAP ScrollTrigger with scrub would be the natural tool. Possibly they used WebGL for 3D objects (the case study mentions 3D obelisks and heavy 3D content). - They also emphasized **optimization**: "arranging sequence for activating scenes and 3D models, followed by optimization iterations"[\[38\]](https://www.awwwards.com/case-study-7-year-journey-by-zajno.html#:~:text=The%20third%20challenge%20involved%20optimizing,this%20experience%20on%20mobile%20devices). This suggests they loaded/unloaded 3D models at certain scroll points to not have everything active at once. They could have used ScrollTrigger callbacks (onEnter, onLeave) to load or dispose of content. - The big shift: user control. They scrapped a timeline that played without input (which made users wait) in favor of scroll = progress. This aligns with modern UX: interactive control is usually superior to passive playback for long animations.

**Key Takeaways:** - **Lesson:** If you have a long sequence, consider making it scroll-driven or interactive rather than timed. Users can go at their pace. Many award sites do this (think of those product reveal pages where you scroll and it animates the product). - GSAP's role: This is exactly what ScrollTrigger scrub is for. They likely used `scrub: true` or a small scrub value to tie the scroll. - The mention of **changing approach** shows the importance of prototyping and user testing. They adjusted to what felt better. - **Performance tweaks**: For heavy content, one might do: - Use `ScrollTrigger.create({..., onEnter: loadScene(index), onLeave: unloadScene(index) })` to handle 3D heavy stuff. - Or break the scroll into sections (each year maybe a section with own trigger). - Use `refreshPriority` on triggers if order of creation doesn't match visual order (they mention sequences -- maybe they used refreshPriority to ensure triggers fire in correct order if overlapping)[\[39\]](https://gsap.com/resources/st-mistakes/#:~:text=To%20fix%20this%20you%20can,property%20to). - Zajno's site likely utilized **GSAP's flexibility**: mixing pinning (maybe pin timeline of text while background 3D moves) and triggers for sequential content.

**Result:** The final experience was both immersive and user-friendly -- the user scrolls through 7 years of content at their own pace, with animations orchestrated perfectly. The site won awards, validating the approach. The AI should note: *complex storytelling is best done with ScrollTrigger to sync narrative to user scroll* -- it's a common theme in high-end sites.
